# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CurvaNivelBR
                                 A QGIS plugin
 Este plugin cria curvas de nível no território brasileiro.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-08
        copyright            : (C) 2024 by Daniel Hulshof Saint Martin
        email                : daniel.hulshof@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Daniel Hulshof Saint Martin'
__date__ = '2024-10-08'
__copyright__ = '(C) 2024 by Daniel Hulshof Saint Martin'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
import os
import inspect
import requests
import zipfile
import tempfile
import subprocess
import processing
from osgeo import gdal, ogr
import osgeo_utils.gdal_merge
from qgis.PyQt.QtGui import (QIcon,
                            QColor)
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsFeature,
                       QgsVectorLayer,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterCrs,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterColor,
                       QgsProcessingUtils,
                       QgsRuleBasedRenderer,
                       QgsVectorLayerSimpleLabeling,
                       QgsPalLayerSettings,
                       QgsTextMaskSettings,
                       QgsSymbolLayerReference,
                       QgsSymbolLayerId,
                       QgsTextMaskSettings,
                       QgsTextFormat,
                       QgsPointXY,
                       QgsGeometry,
                       QgsSymbol)
                       
class CurvaNivelBRAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    AREA_INTERESSE = 'AREA_INTERESSE'
    AREA_INTERESSE_CRS = 'AREA_INTERESSE_CRS'
    INTERVALO = 'INTERVALO'
    COR_CURVAS = 'COR_CURVAS'
    

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # Adiciona entrada da área de interesse
        self.addParameter(QgsProcessingParameterExtent(self.AREA_INTERESSE, "Área de Interesse (selecionar)", optional=False))

        # Adiciona entrada para CRS da area de interesse
        crs_param = QgsProcessingParameterCrs(self.AREA_INTERESSE_CRS, 'CRS da Área de Interesse', optional=True)
        crs_param.setFlags(crs_param.flags() | QgsProcessingParameterDefinition.FlagHidden)
        self.addParameter(crs_param)
        
        # Adiciona intervalo entre curvas
        self.addParameter(
            QgsProcessingParameterNumber(
                name = self.INTERVALO,
                description = self.tr('Intervalo entre curvas'),
                type = QgsProcessingParameterNumber.Integer,
                defaultValue = 10,
                minValue=1, 
                maxValue=1000, 
                optional = True
            )
        )
        
        # Adiciona cor da curva de nivel
        self.addParameter(
            QgsProcessingParameterColor(
                name = self.COR_CURVAS,
                description = self.tr('Coloração das curvas'),
                defaultValue = "#CC8000cc",
                opacityEnabled=True,
                optional = True
            )
        )

        
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT,self.tr('Curvas de Nível')))
        

    def processAlgorithm(self, parameters, context, feedback):

        numeroDeEtapas = 1
        # Compute the number of steps to display within the progress bar and
        # get features from source
        total = 100.0 / numeroDeEtapas
        
        # Instancia parametros de entrada
        area_interesse = self.parameterAsExtent(parameters, self.AREA_INTERESSE, context)
        
        # Define CRS da area de interesse
        area_interesse_crs = self.parameterAsExtentCrs(parameters, self.AREA_INTERESSE, context)
        if self.AREA_INTERESSE_CRS in parameters:
            c = self.parameterAsCrs(parameters, self.TARGET_AREA_CRS, context)
            if c.isValid():
                area_interesse_crs = c

        # Carrega a geometria da área de interesse
        geometria_area_interesse = QgsGeometry.fromRect(area_interesse)
        
        # Carrega o intervalo entre as curvas de nível
        intervalo = self.parameterAsInt(parameters, self.INTERVALO, context)
        
        # Carrega a cor das curvas de nível
        cor_curva = self.parameterAsColor(parameters, self.COR_CURVAS, context)

        
        # Carrega caminho da pasta de armazenamento temporario
        raster_dir = os.getenv("TEMP") + '\CurvaNivelBR'
        caminho_raster = 'http://www.dsr.inpe.br/topodata/data/geotiff/'
        
        # Cria diretório temporário para armazenar arquivos raster
        os.makedirs(raster_dir, exist_ok = True)  
        feedback.pushInfo ('\nAbrindo diretorio: ' + raster_dir)
        
        # Inicializa variaveis
        lista_rasters = []
        lat_norte = 6.0
        lon_oeste = -75.0
        
        
        # Verifica quais arquivos raster serão necessários
        feedback.pushInfo ('\nCalculando sobreposição')
        while (lat_norte > -34.0):
            lon_oeste = -75.0
            while (lon_oeste < -34.5):
                points = [QgsPointXY(lon_oeste, lat_norte), QgsPointXY(lon_oeste + 1.5, lat_norte), QgsPointXY(lon_oeste + 1.5, lat_norte - 1.0), QgsPointXY(lon_oeste, lat_norte - 1.0)]
                poly = QgsGeometry.fromPolygonXY([points])
                
                # Testa sobreposição do polígono de interesse com os rasters
                if not poly.intersection(geometria_area_interesse).isEmpty():

                    # Contrói nome do arquivo raster 
                    nome_raster = list("00S00_ZN")
                    nome_raster[0] = str(abs(int(lat_norte / 10)))
                    nome_raster[1] = str(abs(int(lat_norte)) % 10)
                    if lat_norte > 0:
                        nome_raster[2] = 'N'
                    nome_raster[3] = str(abs(int(lon_oeste / 10)))
                    nome_raster[4] = str(abs(int(lon_oeste)) % 10)
                    if lon_oeste % 1.0 == 0:
                        nome_raster[5] = '_'
                    else:
                        nome_raster[5] = '5'
                
                    if ''.join(nome_raster) not in lista_rasters:
                        lista_rasters.append(''.join(nome_raster))
                    # feedback.pushInfo ('Arquivo: ' + ''.join(nome_raster))
                            
                # feat = QgsFeature()
                # feat.setGeometry(poly)
                # sink.addFeature(feat, QgsFeatureSink.FastInsert)
                
                # feedback.pushInfo ('Lat: ' + str(lat_norte) + ' Lon: ' + str(lon_oeste))
                lon_oeste += 1.5
            lat_norte -= 1.0
        
        
        # Faz download dos rasters
        # TODO: mostrar progresso do download
        # TODO: Resolver autenticação do Proxy
        for raster in lista_rasters:
            feedback.pushInfo ('\nBuscando arquivo Raster: ' + raster + '.tif')
            if os.path.exists(os.path.join(raster_dir, raster + '.tif')):
                feedback.pushInfo ('Arquivo localizado no disco')
            else:
                feedback.pushInfo ('Baixando arquivo: ' + raster)
                raster_url = caminho_raster + raster + '.zip'
                with requests.get(raster_url, allow_redirects = True) as r:
                    r.raise_for_status()
                    with tempfile.TemporaryFile() as zip:
                        zip.write(r.content)
                        with zipfile.ZipFile(zip) as zf:
                            files = zf.namelist()
                            for filename in files:
                                feedback.pushInfo ('Descompactando arquivo: ' + filename)
                                file_path = os.path.join(raster_dir, filename)
                                f = open(file_path, 'wb')
                                f.write(zf.read(filename))
                                f.close()
       
        # Para cada raster baixado faz o corte para a área de sobreposição com a área de interesse
        feedback.pushInfo ('\nRecortando arquivos raster para área de interesse')
        raster_clips = []
        for raster in lista_rasters:
            raster_clips.append(os.path.join(raster_dir, raster + '_clip.tif'))
            fn_in = os.path.join(raster_dir, raster + '.tif')
            fn_clip = os.path.join(raster_dir, raster + '_clip.tif')
            
            #feedback.pushInfo ('Cortando: ' + raster + '.tif')
            #feedback.pushInfo ('Poligono: ' + fn_poly + ' Layer: ' + fn_layer)
            #subprocess.run(f'gdalwarp -overwrite -s_srs EPSG:4326 -t_srs EPSG:4326 -of GTiff -cutline "{fn_poly}" -cl "area interesse" -crop_to_cutline -dstnodata 0.0 {fn_in} {fn_clip}')
            result = gdal.Warp(fn_clip, fn_in, cutlineWKT=geometria_area_interesse.asWkt(), cropToCutline=True, dstNodata=0, srcSRS='EPSG:4326', dstSRS='EPSG:4326', format='GTiff')
            result = None
        
        # Unifica todas as partes recortadas dos rasters
        feedback.pushInfo ('\nUnificando arquivos raster da área de interesse')
        g = gdal.Warp(os.path.join(raster_dir, 'merged.tif'), raster_clips, format="GTiff")
        g = None
       
        # Gera as curvas de nível a partir da imagem unificada
        feedback.pushInfo ('\nGerando curvas de nível')
        output_shp = os.path.join(raster_dir, 'curvasdenivel.shp')
        ogr_ds = ogr.GetDriverByName("ESRI Shapefile").CreateDataSource(output_shp)
        ogr_lyr = ogr_ds.CreateLayer("Curvas De Nivel")
        field_defn = ogr.FieldDefn("ID", ogr.OFTInteger)
        ogr_lyr.CreateField(field_defn)
        field_defn = ogr.FieldDefn("ELEV", ogr.OFTReal)
        ogr_lyr.CreateField(field_defn)
        ds = gdal.Open(os.path.join(raster_dir, 'merged.tif'))
        gdal.ContourGenerate(ds.GetRasterBand(1), intervalo, 0, [], 0, 0, ogr_lyr, 0, 1)
        ogr_ds = None
        ds = None
  
        # Grava dados no arquivo de saída
        layer = QgsVectorLayer(output_shp, 'Curvas De Nivel')
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, layer.fields(), layer.wkbType(), area_interesse_crs)
        for feature in layer.getFeatures():
            sink.addFeature(feature, QgsFeatureSink.FastInsert)
            
        # Modifica a simbologia
        layer_curvas = QgsProcessingUtils.mapLayerFromString(dest_id, context)
        symbol = QgsSymbol.defaultSymbol(layer_curvas.geometryType())
        renderer = QgsRuleBasedRenderer(symbol)
        root_rule = renderer.rootRule()
        
        # Curva Mestra
        rule = root_rule.children()[0]
        rule.setLabel("Curva Mestra")
        rule.setFilterExpression(f'"ELEV" % {intervalo*5} = 0')
        rule.symbol().setColor(cor_curva)
        rule.symbol().setWidth(0.5)
          
        # Curva Normal           
        rule = root_rule.children()[0].clone()
        rule.setLabel("Curva Normal")
        rule.setFilterExpression(f'"ELEV" % {intervalo*5} != 0')
        rule.symbol().setColor(cor_curva)
        rule.symbol().setWidth(0.25)
        root_rule.appendChild(rule)
        
        # Salva as regras de curva
        layer_curvas.setRenderer(renderer)
        layer_curvas.triggerRepaint()
        
        # Modifica os labels
        # Configure label settings
        # Cria mascara
        mask = QgsTextMaskSettings()
        mask.setSize(2)
        mask.setMaskedSymbolLayers([QgsSymbolLayerReference(layer_curvas.id(), rule.symbol().symbolLayer(0).id())])
        mask.setEnabled(True)
        # Configura texto
        textFormat = QgsTextFormat()
        textFormat.setSize(10)
        textFormat.setColor(cor_curva)
        textFormat.setMask(mask)
        # Salva configurações
        settings = QgsPalLayerSettings()
        settings.fieldName = f'CASE WHEN "ELEV" % {intervalo*5} = 0 THEN "ELEV" ELSE \'\' END'
        settings.enabled = True
        settings.drawLabels = True
        settings.isExpression = True
        settings.placement = QgsPalLayerSettings.Line
        settings.placementFlags = QgsPalLayerSettings.OnLine
        settings.setFormat(textFormat)

        layer_curvas.setLabelsEnabled(True)
        layer_curvas.setLabeling(QgsVectorLayerSimpleLabeling(settings))
        layer_curvas.triggerRepaint()
        
        # Ao final apaga diretório temporário
        feedback.pushInfo ('\nFinalizou com sucesso\n')
        
        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT: dest_id}

    def icon(self):
        cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]
        icon = QIcon(os.path.join(os.path.join(cmd_folder, 'logo.png')))
        return icon
        
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Gerar Curva de Nivel'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CurvaNivelBRAlgorithm()
